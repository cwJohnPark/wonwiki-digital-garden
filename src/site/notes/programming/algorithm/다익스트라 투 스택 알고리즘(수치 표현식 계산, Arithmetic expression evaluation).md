---
{"dg-publish":true,"permalink":"/programming/algorithm/arithmetic-expression-evaluation/"}
---



컴퓨터는 아래와 같은 수치 표현식을 어떻게 계산할까?

$$
(\;1\; + \; ( \; ( \; 2 \; + \; 3 \; ) \; * \; ( \; 4 \; *  \; 5 \; ) \; ) \; )
$$

1960년대에 E. W. 다익스트라는 피연산자용(숫자) 스택과 연산자용 스택, 두 개의 스택을 사용하여 수치 표현식을 계산하는 알고리즘을 고안했다.

표현식은 괄호, 연산자, 피연산자(숫자)라는 엔티티들로 구성된다. 
왼쪽에서 오른쪽으로 진행하면서 이러한 엔티티를 한 번에 하나씩 가져와서 다음과 같이 네 가지 가능한 경우에 따라 스택을 이용한다.

- 피연산자를 피연산자 스택에 push한다.
- 연산자를 연산자 스택으로 push한다.
- 여는 괄호 "(" 는 무시한다.
- 닫는 괄호 ")" 를 만나면 연산자를 pop한다.
- 꺼내온 연산자에 필요한 갯수만큼의 피연산자를 pop한다.
- 꺼내온 연산자와 피연산자를 이용해 evaluation(계산)한다.
- 적용한 결과는 피연산자 스택에 push한다.


## 알고리즘 예제

$$1 + ( ( 2 + 3 ) * ( 4 * 5 ) ) )$$
- 왼쪽부터 피연산자와 연산자를 각각의 스택에 넣는다.

| 연산자 스택 | 피연산자 스택 |
| ------ | ------- |
| +, +   | 1, 2, 3 |

- (2 + 3)의 오른쪽 괄호를 만났다.
- 피연산자 3,2와 연산자 **+** 를 pop한다.
- (3+2) 를 계산한다.
- 결과 5를 피연산자 스택에 push 한다.

| 연산자 스택 | 피연산자 스택 |
| ------ | ------- |
| +      | 1, 5    |

$$( 1 + ( 5 * ( 4 * 5 ) ) ) $$
- 연산자 `*` 를  연산자 스택에 push 한다.
- 피연산자 `4`, `5`와 피연산자 `*`를 각각 스택에 push 한다.

| 연산자 스택    | 피연산자 스택    |
| --------- | ---------- |
| +, \*, \* | 1, 5, 4, 5 |

- `(4 * 5)` 의 닫는 괄호를 만났다.
- 연산자 스택에서 `*`를, 피연산자 스택에서 `5, 4` 를 pop 한다.
- `(4 * 5)` 를 계산하고 결과를 피연산자 스택에 push 한다.

| 연산자 스택 | 피연산자 스택  |
| ------ | -------- |
| +, \*  | 1, 5, 20 |

$$( 1 + ( 5 * 20 ) )$$
- `(5 * 20)` 의 닫는 괄호를 만났다.
- 피연산자 스택에서 `*` 를, 연산자 스택에서 `5, 20`을 pop 한다.
- `(5 * 20)` 을 계산하고 피연산자 스택에 push 한다.

| 연산자 스택 | 피연산자 스택 |
| ------ | ------- |
| +      | 1, 100  |

$$ ( 1 + 100 )$$
- `(1 + 100)` 의 닫는 괄호를 만났다.
- 연산 스택에서 연산자 `+` 와 피연산자 `1, 100` 을 pop 한다.
- `(1 + 100)` 을 계산하고 피연산자 스택에 넣는다.

 
$$ 101 $$
- 최종적으로 연산자 스택에 아무것도 남지 않고 피연산자 스택에 하나의 결과 값이 저장되었다.


## 코틀린 코드 예제
```kotlin
  
fun twoStacks() {  
	// 수치 표현식 문자열  
    val expression = "1 + ( ( 2 + 3 ) * ( 4 * 5 ) )" 
    // 공백 기준으로 토큰화  
    val tokens = expression.split(" ").filter { it.isNotBlank() } 
	// 연산자 스택  
    val ops = Stack<String>()
    // 값 스택  
    val vals = Stack<Double>()
  
    for (token in tokens) {  
        when (token) {  
            "(" -> {  
                // 여는 괄호는 무시  
            }  
            "+", "-", "*", "/", "sqrt" -> {  
	            // 연산자를 스택에 추가  
                ops.push(token) 
            }  
            ")" -> {  
                // 닫는 괄호를 만나면 계산  
                val op = ops.pop()  
                var v = vals.pop()  
                when (op) {  
                    "+" -> v = vals.pop() + v  
                    "-" -> v = vals.pop() - v  
                    "*" -> v = vals.pop() * v  
                    "/" -> v = vals.pop() / v  
                    "sqrt" -> v = sqrt(v)  
                }  
                // 계산 결과를 값 스택에 푸시  
                vals.push(v)
            }  
            else -> {  
                // 숫자일 경우 값을 스택에 추가  
                vals.push(token.toDouble())  
            }  
        }  
    }  
  
    val result = vals.pop()  
    // 최종 결과 출력 101.0
    println("Result: $result") 
}
```

---

Robert, Sedgewick; Wayne Kevin. Algorithms (p. 130). Pearson Education. Kindle Edition. 